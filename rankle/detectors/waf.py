"""
WAF (Web Application Firewall) Detection Module for Rankle

Detects Web Application Firewalls through passive techniques:
- HTTP Headers analysis
- Response body patterns
- Cookie names
- Error page signatures
"""

import re
from typing import Any


# WAF Signatures Database
WAF_SIGNATURES: dict[str, dict[str, Any]] = {
    "Cloudflare": {
        "headers": {
            "cf-ray": [""],
            "cf-chl-bypass": [""],
            "server": [r"^cloudflare$"],
        },
        "cookies": ["__cfruid", "cf_clearance", "__cf_bm"],
        "body_patterns": [
            r"Attention Required! \| Cloudflare",
            r"cloudflare.com/cdn-cgi/",
            r"Ray ID:",
            r"cf-error-details",
        ],
    },
    "AWS WAF": {
        "headers": {
            "x-amzn-waf-": [""],
            "x-amzn-requestid": [""],
        },
        "cookies": ["awswaf", "aws-waf-token"],
        "body_patterns": [
            r"Request blocked",
            r"awswaf",
        ],
    },
    "Akamai Kona": {
        "headers": {
            "server": [r"AkamaiGHost"],
            "x-akamai-": [""],
            "akamai-origin-hop": [""],
        },
        "cookies": ["ak_bmsc", "bm_sv", "bm_sz", "_abck"],
        "body_patterns": [
            r"Access Denied",
            r"Reference.*#[0-9a-f.]+",
            r"AkamaiGHost",
        ],
    },
    "Imperva/Incapsula": {
        "headers": {
            "x-iinfo": [""],
            "x-cdn": [r"Incapsula", r"Imperva"],
        },
        "cookies": ["visid_incap", "incap_ses", "nlbi_", "reese84"],
        "body_patterns": [
            r"incapsula",
            r"/_Incapsula_Resource",
            r"Request unsuccessful",
        ],
    },
    "Sucuri": {
        "headers": {
            "x-sucuri-id": [""],
            "x-sucuri-cache": [""],
            "server": [r"Sucuri"],
        },
        "cookies": ["sucuri_cloudproxy_uuid"],
        "body_patterns": [
            r"sucuri",
            r"Access Denied - Sucuri",
            r"Sucuri WebSite Firewall",
        ],
    },
    "ModSecurity": {
        "headers": {
            "server": [r"ModSecurity", r"NOYB"],
        },
        "cookies": [],
        "body_patterns": [
            r"ModSecurity",
            r"mod_security",
            r"This error was generated by Mod_Security",
            r"NOYB",
        ],
    },
    "F5 BIG-IP ASM": {
        "headers": {
            "x-wa-info": [""],
            "x-cnection": [r"close"],
            "server": [r"BigIP", r"BIG-IP"],
        },
        "cookies": ["TS", "BIGipServer", "F5_ST", "F5_HT_shrinked"],
        "body_patterns": [
            r"The requested URL was rejected",
            r"BIG-IP",
            r"F5 Networks",
        ],
    },
    "Fortinet FortiWeb": {
        "headers": {
            "server": [r"FortiWeb"],
        },
        "cookies": ["FORTIWAFSID"],
        "body_patterns": [
            r"FortiWeb",
            r".fgd_icon",
            r"Server unavailable",
        ],
    },
    "Barracuda": {
        "headers": {
            "server": [r"Barracuda"],
        },
        "cookies": ["barra_counter_session"],
        "body_patterns": [
            r"Barracuda",
            r"barra_counter_session",
        ],
    },
    "Citrix NetScaler": {
        "headers": {
            "via": [r"NS-CACHE"],
            "x-nsprotect": [""],
            "cneonction": [r"close"],
            "nneonction": [r"close"],
        },
        "cookies": ["ns_af", "citrix_ns_id", "NSC_"],
        "body_patterns": [
            r"ns_af=",
            r"Citrix",
            r"NetScaler",
        ],
    },
    "DenyAll": {
        "headers": {
            "x-denyall": [""],
        },
        "cookies": ["sessioncookie"],
        "body_patterns": [
            r"Condition Intercepted",
            r"DenyAll",
        ],
    },
    "Palo Alto": {
        "headers": {},
        "cookies": [],
        "body_patterns": [
            r"has been blocked in accordance with company policy",
            r"Palo Alto Next Generation Security Platform",
        ],
    },
    "Wallarm": {
        "headers": {
            "server": [r"nginx-wallarm"],
        },
        "cookies": [],
        "body_patterns": [
            r"wallarm",
            r"nginxwallarm",
        ],
    },
    "Reblaze": {
        "headers": {
            "server": [r"Reblaze Secure Web Gateway"],
            "x-rpb-": [""],
        },
        "cookies": ["rbzid", "rbzsessionid"],
        "body_patterns": [
            r"Reblaze",
            r"Access Denied",
        ],
    },
    "PerimeterX": {
        "headers": {},
        "cookies": ["_px", "_pxvid", "_pxhd"],
        "body_patterns": [
            r"PerimeterX",
            r"blocked.*perimeterx",
            r"www.perimeterx.com/whywasiblocked",
        ],
    },
    "DataDome": {
        "headers": {
            "x-datadome": [""],
        },
        "cookies": ["datadome", "datadome-_zldp"],
        "body_patterns": [
            r"DataDome",
            r"datadome.co",
        ],
    },
    "Shape Security": {
        "headers": {},
        "cookies": ["_imp_apg_r_", "_imp_apg_v_"],
        "body_patterns": [],
    },
    "StackPath": {
        "headers": {
            "x-sp-": [""],
            "x-hw": [""],
        },
        "cookies": [],
        "body_patterns": [
            r"StackPath",
            r"Request blocked",
        ],
    },
    "Varnish": {
        "headers": {
            "via": [r"varnish"],
            "x-varnish": [""],
        },
        "cookies": [],
        "body_patterns": [
            r"Error 503 Backend fetch failed",
            r"XID:",
            r"Varnish cache server",
        ],
    },
    "Wordfence": {
        "headers": {},
        "cookies": ["wfwaf-authcookie"],
        "body_patterns": [
            r"Generated by Wordfence",
            r"wordfence",
            r"This response was generated by Wordfence",
        ],
    },
    "Comodo": {
        "headers": {
            "server": [r"Protected by COMODO"],
        },
        "cookies": [],
        "body_patterns": [
            r"COMODO",
            r"Protected by COMODO",
        ],
    },
    "LiteSpeed": {
        "headers": {
            "server": [r"LiteSpeed"],
        },
        "cookies": [],
        "body_patterns": [
            r"Powered By LiteSpeed",
            r"LiteSpeed Web Server",
        ],
    },
    "Safe3": {
        "headers": {
            "x-powered-by": [r"Safe3WAF"],
            "server": [r"Safe3"],
        },
        "cookies": ["Safe3"],
        "body_patterns": [
            r"Safe3",
        ],
    },
    "Qrator": {
        "headers": {
            "x-qrator-": [""],
        },
        "cookies": ["qrator_jsid"],
        "body_patterns": [
            r"Qrator",
        ],
    },
    "Edgecast": {
        "headers": {
            "server": [r"ECS", r"ECAcc", r"ECACC"],
        },
        "cookies": [],
        "body_patterns": [],
    },
}


class WAFDetector:
    """
    Detects Web Application Firewalls using passive techniques.

    Analyzes HTTP headers, cookies, and response body patterns
    to identify WAF presence without triggering active blocks.
    """

    def __init__(self, domain: str):
        """
        Initialize WAF detector.

        Args:
            domain: Target domain
        """
        self.domain = domain

    def detect(
        self,
        headers: dict[str, str] | None = None,
        cookies: list[str] | None = None,
        body: str | None = None,
    ) -> dict[str, Any]:
        """
        Perform WAF detection.

        Args:
            headers: HTTP response headers
            cookies: Cookie names from response
            body: Response body text (first few KB is enough)

        Returns:
            Dictionary with detection results
        """
        results: dict[str, Any] = {
            "detected": False,
            "waf": None,
            "confidence": 0.0,
            "evidence": [],
            "all_matches": [],
        }

        # Collect all evidence
        header_matches = self._check_headers(headers) if headers else []
        cookie_matches = self._check_cookies(cookies) if cookies else []
        body_matches = self._check_body(body) if body else []

        # Aggregate results
        all_evidence: dict[str, list[dict[str, Any]]] = {}

        for match in header_matches + cookie_matches + body_matches:
            waf_name = match["waf"]
            if waf_name not in all_evidence:
                all_evidence[waf_name] = []
            all_evidence[waf_name].append(match)

        # Calculate confidence for each WAF
        waf_scores: list[dict[str, Any]] = []
        for waf_name, evidence_list in all_evidence.items():
            confidence = self._calculate_confidence(evidence_list)
            waf_scores.append(
                {
                    "waf": waf_name,
                    "confidence": confidence,
                    "evidence": evidence_list,
                }
            )

        # Sort by confidence
        waf_scores.sort(key=lambda x: x["confidence"], reverse=True)

        if waf_scores and waf_scores[0]["confidence"] >= 0.3:
            best_match = waf_scores[0]
            results["detected"] = True
            results["waf"] = best_match["waf"]
            results["confidence"] = best_match["confidence"]
            results["evidence"] = best_match["evidence"]
            results["all_matches"] = waf_scores

        return results

    def _check_headers(self, headers: dict[str, str]) -> list[dict[str, Any]]:
        """Check HTTP headers for WAF signatures."""
        matches = []
        headers_lower = {k.lower(): v for k, v in headers.items()}

        for waf_name, signatures in WAF_SIGNATURES.items():
            waf_headers = signatures.get("headers", {})
            for header_pattern, value_patterns in waf_headers.items():
                header_pattern_lower = header_pattern.lower()

                for header_name, header_value in headers_lower.items():
                    # Prefix match (e.g., "x-akamai-")
                    if header_pattern_lower.endswith("-"):
                        if header_name.startswith(header_pattern_lower):
                            matches.append(
                                {
                                    "waf": waf_name,
                                    "type": "header",
                                    "detail": f"{header_name}: {header_value[:50]}",
                                    "weight": 0.5,
                                }
                            )
                    elif header_name == header_pattern_lower:
                        for pattern in value_patterns:
                            if not pattern:
                                matches.append(
                                    {
                                        "waf": waf_name,
                                        "type": "header",
                                        "detail": f"{header_name} header present",
                                        "weight": 0.4,
                                    }
                                )
                                break
                            if re.search(pattern, header_value, re.IGNORECASE):
                                matches.append(
                                    {
                                        "waf": waf_name,
                                        "type": "header",
                                        "detail": f"{header_name}: {header_value[:50]}",
                                        "weight": 0.5,
                                    }
                                )
                                break

        return matches

    def _check_cookies(self, cookies: list[str]) -> list[dict[str, Any]]:
        """Check cookie names for WAF signatures."""
        matches = []

        for waf_name, signatures in WAF_SIGNATURES.items():
            waf_cookies = signatures.get("cookies", [])
            for waf_cookie in waf_cookies:
                for cookie in cookies:
                    # Check if cookie starts with or matches the WAF pattern
                    cookie_lower = cookie.lower()
                    waf_cookie_lower = waf_cookie.lower()
                    if (
                        cookie_lower.startswith(waf_cookie_lower)
                        or cookie_lower == waf_cookie_lower
                    ):
                        matches.append(
                            {
                                "waf": waf_name,
                                "type": "cookie",
                                "detail": f"Cookie: {cookie}",
                                "weight": 0.4,
                            }
                        )

        return matches

    def _check_body(self, body: str) -> list[dict[str, Any]]:
        """Check response body for WAF signatures."""
        matches = []

        # Only check first 50KB for performance
        body_sample = body[:50000]

        for waf_name, signatures in WAF_SIGNATURES.items():
            for pattern in signatures.get("body_patterns", []):
                if re.search(pattern, body_sample, re.IGNORECASE):
                    matches.append(
                        {
                            "waf": waf_name,
                            "type": "body",
                            "detail": f"Body pattern: {pattern[:30]}...",
                            "weight": 0.3,
                        }
                    )

        return matches

    def _calculate_confidence(self, evidence: list[dict[str, Any]]) -> float:
        """Calculate confidence score from evidence."""
        if not evidence:
            return 0.0

        by_type: dict[str, list[float]] = {}
        for ev in evidence:
            ev_type = ev["type"]
            if ev_type not in by_type:
                by_type[ev_type] = []
            by_type[ev_type].append(ev["weight"])

        total_score = 0.0
        for weights in by_type.values():
            weights.sort(reverse=True)
            type_score = weights[0]
            for i, w in enumerate(weights[1:], 1):
                type_score += w * (0.5**i)
            total_score += type_score

        return min(1.0, total_score)


def detect_waf(
    domain: str,
    headers: dict[str, str] | None = None,
    cookies: list[str] | None = None,
    body: str | None = None,
) -> dict[str, Any]:
    """
    Convenience function for WAF detection.

    Args:
        domain: Target domain
        headers: HTTP response headers
        cookies: Cookie names
        body: Response body

    Returns:
        WAF detection results
    """
    detector = WAFDetector(domain)
    return detector.detect(headers=headers, cookies=cookies, body=body)
